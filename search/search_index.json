{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Advanced Color Picker Documentation Welcome to the documentation for the Advanced Color Picker component found in Core Community Content. This component will help make your game more customizable for your players. If you want to get up and running quickly, then read the Quick Start guide, otherwise I would recommend reading he Need to Know and then try out the examples that come with the content.","title":"Home"},{"location":"#advanced-color-picker-documentation","text":"Welcome to the documentation for the Advanced Color Picker component found in Core Community Content. This component will help make your game more customizable for your players. If you want to get up and running quickly, then read the Quick Start guide, otherwise I would recommend reading he Need to Know and then try out the examples that come with the content.","title":"Advanced Color Picker Documentation"},{"location":"add-modify-colors/","text":"Modifying the Palette The color palette is built in such a way that you can add and modify colors and the component will dynamically create the palette for you. This saves you from having to place each color by hand in the palette. The component contains 2 custom properties to handle how many colors appear per row and the spacing between them. colors_per_row The amount of colors on each row of the palette. color_spacing The spacing around the edge of the panel and between each color. You can also easily add more colors by adding more buttons to the palette.","title":"Modifying the Palette"},{"location":"add-modify-colors/#modifying-the-palette","text":"The color palette is built in such a way that you can add and modify colors and the component will dynamically create the palette for you. This saves you from having to place each color by hand in the palette. The component contains 2 custom properties to handle how many colors appear per row and the spacing between them. colors_per_row The amount of colors on each row of the palette. color_spacing The spacing around the edge of the panel and between each color. You can also easily add more colors by adding more buttons to the palette.","title":"Modifying the Palette"},{"location":"contexts/","text":"Contexts This component will only work with client contexts. Client Context Networked Client Context Any other context will likely throw an error and adds more complexity. More information on Contexts","title":"Contexts"},{"location":"contexts/#contexts","text":"This component will only work with client contexts. Client Context Networked Client Context Any other context will likely throw an error and adds more complexity. More information on Contexts","title":"Contexts"},{"location":"hierarchy/","text":"Add to Hierarchy Before you can use the component, you will need to place it into your hierarchy. In the Project Content window, find the Advanced Color Picker component. Drag the component into your hierarchy which should now contain the component like so.","title":"Add to Hierarchy"},{"location":"hierarchy/#add-to-hierarchy","text":"Before you can use the component, you will need to place it into your hierarchy. In the Project Content window, find the Advanced Color Picker component. Drag the component into your hierarchy which should now contain the component like so.","title":"Add to Hierarchy"},{"location":"ignore-mesh-objects/","text":"Ignoring Mesh Objects In some cases you may not want specific mesh objects or groups of mesh objects to be colored. This is very easy to do by using custom properties. For any mesh object or folder of mesh objects, you can apply a custom property called ignore_color_picker . When ticked, this will tell the component that this mesh object or folder of mesh objects needs to be ignored. In this example I want to disable the Head from being colored, but still allow the eyes to be colored. Click on the object to make it active. In the properties panel at the bottom, you will see a button called Add Custom Property . Click on the button and add a Bool property. A window will popup where you need to name the custom property. In this case the name of the property needs to be ignore_color_picker . The new property will now show up. Click the checkbox to enable it. The component will see this property and if it is ticked then this mesh object or folder of mesh objects will be ignored. So now if I look at my color picker hierarchy, the Head will no longer be an option to color.","title":"Ignoring Mesh Objects"},{"location":"ignore-mesh-objects/#ignoring-mesh-objects","text":"In some cases you may not want specific mesh objects or groups of mesh objects to be colored. This is very easy to do by using custom properties. For any mesh object or folder of mesh objects, you can apply a custom property called ignore_color_picker . When ticked, this will tell the component that this mesh object or folder of mesh objects needs to be ignored. In this example I want to disable the Head from being colored, but still allow the eyes to be colored. Click on the object to make it active. In the properties panel at the bottom, you will see a button called Add Custom Property . Click on the button and add a Bool property. A window will popup where you need to name the custom property. In this case the name of the property needs to be ignore_color_picker . The new property will now show up. Click the checkbox to enable it. The component will see this property and if it is ticked then this mesh object or folder of mesh objects will be ignored. So now if I look at my color picker hierarchy, the Head will no longer be an option to color.","title":"Ignoring Mesh Objects"},{"location":"mesh-objects/","text":"Setup Mesh Objects Your mesh objects should be in a folder that will be the mesh_root (container). An example of an ideal structure for a character. The thing to take away from the image above is good naming of each mesh object. It's recommended because the name of the mesh object is used in the hierarchy of the color picker. Take a look at the color picker hierarchy below. Players will be able to easily identify which part of the object they are coloring.","title":"Setup Mesh Objects"},{"location":"mesh-objects/#setup-mesh-objects","text":"Your mesh objects should be in a folder that will be the mesh_root (container). An example of an ideal structure for a character. The thing to take away from the image above is good naming of each mesh object. It's recommended because the name of the mesh object is used in the hierarchy of the color picker. Take a look at the color picker hierarchy below. Players will be able to easily identify which part of the object they are coloring.","title":"Setup Mesh Objects"},{"location":"mesh-root/","text":"Mesh Root The most important thing you need to know about this component is to set the mesh_root property. If you don't do this, then the component will not be able to find mesh objects and display them in the list to be colored. With the component added to the Hierarchy click on it to make it the focused object. In the properties panel you will see custom properties, one being mesh_root . This is where you need to drag your mesh root folder to.","title":"Mesh Root"},{"location":"mesh-root/#mesh-root","text":"The most important thing you need to know about this component is to set the mesh_root property. If you don't do this, then the component will not be able to find mesh objects and display them in the list to be colored. With the component added to the Hierarchy click on it to make it the focused object. In the properties panel you will see custom properties, one being mesh_root . This is where you need to drag your mesh root folder to.","title":"Mesh Root"},{"location":"object-picking/","text":"Object Picking The componet has a simple API where you can pass in a mesh_root dynamically. This is a good idea if you want your player to be able to pick different objects to color. See example 4 that demostrates how to switch objects. Example code of how we can connect a pressed event to a button and when clicked it will change the mesh_root of the Advanced Color Picker component. 1 2 3 4 5 6 7 8 9 10 11 12 13 local container = script : GetCustomProperty ( \"button_container\" ): WaitForObject () -- A reference to the color picker component local color_picker = script : GetCustomProperty ( \"color_picker\" ): WaitForObject () for b = 1 , # container : GetChildren () do local button = container : GetChildren ()[ b ] button . pressedEvent : Connect ( function () -- On pressed we give the color picker component a new mesh_root color_picker . context . set_mesh_root ( button : GetCustomProperty ( \"mesh_root\" )) end ) end","title":"Object Picking"},{"location":"object-picking/#object-picking","text":"The componet has a simple API where you can pass in a mesh_root dynamically. This is a good idea if you want your player to be able to pick different objects to color. See example 4 that demostrates how to switch objects. Example code of how we can connect a pressed event to a button and when clicked it will change the mesh_root of the Advanced Color Picker component. 1 2 3 4 5 6 7 8 9 10 11 12 13 local container = script : GetCustomProperty ( \"button_container\" ): WaitForObject () -- A reference to the color picker component local color_picker = script : GetCustomProperty ( \"color_picker\" ): WaitForObject () for b = 1 , # container : GetChildren () do local button = container : GetChildren ()[ b ] button . pressedEvent : Connect ( function () -- On pressed we give the color picker component a new mesh_root color_picker . context . set_mesh_root ( button : GetCustomProperty ( \"mesh_root\" )) end ) end","title":"Object Picking"},{"location":"quick-start/","text":"Quick Start If you want to get up and running quickly then follow the steps below. Drag the Advanced Color Picker component into your hierarchy. Drag your folder containing your mesh objects on to the property called mesh_root of the Advanced Color Picker component. Enter play mode and press P and test out coloring by selecting an item from the list and picking a color.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"If you want to get up and running quickly then follow the steps below. Drag the Advanced Color Picker component into your hierarchy. Drag your folder containing your mesh objects on to the property called mesh_root of the Advanced Color Picker component. Enter play mode and press P and test out coloring by selecting an item from the list and picking a color.","title":"Quick Start"},{"location":"examples/example1/","text":"A Simple Cube Drag the Mesh Root folder onto the mesh_root property of the Advanced Color Picker component. Enter play mode and press P . You will be able to pick the Cube and change the color of it.","title":"A Simple Cube"},{"location":"examples/example1/#a-simple-cube","text":"Drag the Mesh Root folder onto the mesh_root property of the Advanced Color Picker component. Enter play mode and press P . You will be able to pick the Cube and change the color of it.","title":"A Simple Cube"},{"location":"examples/example2/","text":"Multiple Mesh Objects This example shows you how good naming of your mesh objects and folders can help with identifying which part is being colored in the Color Picker Hierarchy. As with the previous example, remember to set the mesh_root . Enter play mode and press P and begin coloring each part of the character.","title":"Multiple Mesh Objects"},{"location":"examples/example2/#multiple-mesh-objects","text":"This example shows you how good naming of your mesh objects and folders can help with identifying which part is being colored in the Color Picker Hierarchy. As with the previous example, remember to set the mesh_root . Enter play mode and press P and begin coloring each part of the character.","title":"Multiple Mesh Objects"},{"location":"examples/example3/","text":"Ignoring Mesh Objects In this example it shows how we can use the ignore feature. Expand the folder and look at the Arms folder. You will see a custom property called ignore_color_picker . What this does is tells the Advanced Color Picker to ignore this object and anything that is a child of it. When you run the example, you will see the arm object meshes will not be visible in the UI to be colored.","title":"Ignoring Mesh Objects"},{"location":"examples/example3/#ignoring-mesh-objects","text":"In this example it shows how we can use the ignore feature. Expand the folder and look at the Arms folder. You will see a custom property called ignore_color_picker . What this does is tells the Advanced Color Picker to ignore this object and anything that is a child of it. When you run the example, you will see the arm object meshes will not be visible in the UI to be colored.","title":"Ignoring Mesh Objects"},{"location":"examples/example4/","text":"Object Switching This example shows you how to handle object switching. Once setup, you will be able to switch between the first 3 examples by clicking on the example buttons. Expand the folder and take a look the custom properties of the Advanced_Color_Picker_Switcher_Client script. It's important that this script has a reference to the Advanced_Color_Picker_Client script so we can call the set_mesh_root method. Enter play mode and press P . You will be able to click on the buttons and switch between the first 3 examples.","title":"Object Switching"},{"location":"examples/example4/#object-switching","text":"This example shows you how to handle object switching. Once setup, you will be able to switch between the first 3 examples by clicking on the example buttons. Expand the folder and take a look the custom properties of the Advanced_Color_Picker_Switcher_Client script. It's important that this script has a reference to the Advanced_Color_Picker_Client script so we can call the set_mesh_root method. Enter play mode and press P . You will be able to click on the buttons and switch between the first 3 examples.","title":"Object Switching"},{"location":"examples/example5/","text":"Saving Colors This example is an extra bonus but more advanced. What's the point of allowing the players to change colors of an object if they don't save? So some important things to note about this example: Enable saving_enabled on the Advanced_Color_Picker_Save_Load_Client script. It is disabled by default. Your mesh root needs to be networked and have a networked property called data . See the example by looking at Mesh Root . Player Data has a limit of how much can be stored, so if you are letting the player color the world, expect to hit the limit. For simple objects where it may be a hat, or some clothing, then this should be fine. This example storage an object that is built up of the mesh ids and the color picked. We send the data to a server script which handles saving to Player Storage. When a player logs back in, we convert the data into a string and use a networked property so we can get it to the client. See Storage for more information. The Server Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 local mesh_root = script : GetCustomProperty ( \"mesh_root\" ): WaitForObject () local enable_loading = script : GetCustomProperty ( \"enable_loading\" ) -- Turns a table of that was stored in the player storage into a string so we can -- set the networked property value. function stringify_data ( data ) local str = {} for k , v in pairs ( data ) do table.insert ( str , # str + 1 , string.format ( \"|%s|%.2f|%.2f|%.2f\" , k , v . r , v . g , v . b )) end return table.concat ( str ) end -- When player joins the game, grab their data, turn it into a string, and send it to them -- via a networked property. Game . playerJoinedEvent : Connect ( function ( player ) local data = Storage . GetPlayerData ( player ) or {} mesh_root : SetNetworkedCustomProperty ( \"data\" , stringify_data ( data )) end ) -- Handles saving the color to storage for the player. Events . ConnectForPlayer ( \"on_color_picker_save\" , function ( player , id , color ) local data = Storage . GetPlayerData ( player ) or {} data [ id ] = color Storage . SetPlayerData ( player , data ) end ) The Client Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 local mesh_root = script : GetCustomProperty ( \"mesh_root\" ): WaitForObject () local enable_saving = script : GetCustomProperty ( \"enable_saving\" ) -- If saving is enabled, then we broadcast to the server when a color is changed. -- Ideally it would be nice not to have to broadcast every time, but if we try to send -- all the colors and mesh ids to the server, we will hit either broadcast rate limits, -- or data limits. if ( enable_saving ) then Events . Connect ( \"on_color_picker_object_changed\" , function ( id , color ) local a , j = string.find ( id , \":\" ) Events . BroadcastToServer ( \"on_color_picker_save\" , string.sub ( id , 0 , j - 1 ), color ) end ) end -- Here we listen for a change on the networked property. We handle turning the -- data back into a table so we can then apply the colors to the mesh. mesh_root . networkedPropertyChangedEvent : Connect ( function ( obj , prop ) if ( prop == \"data\" ) then local data = unstringify_data ( mesh_root : GetCustomProperty ( prop )) local objs = get_objects ( mesh_root , {}) for k , v in pairs ( data ) do for o = 1 , # objs do local a , j = string.find ( objs [ o ]. id , \":\" ) local id = string.sub ( objs [ o ]. id , 0 , j - 1 ) if ( id == k ) then objs [ o ]: SetColor ( Color . New ( v [ 1 ], v [ 2 ], v [ 3 ])) end end end end end ) function get_objects ( r , objs ) local children = r : GetChildren () for c = 1 , # children do local child = children [ c ] if ( not child : GetCustomProperty ( \"ignore_color_picker\" )) then if ( child : IsA ( \"StaticMesh\" )) then table.insert ( objs , # objs + 1 , child ) elseif ( child : IsA ( \"Folder\" )) then objs = get_objects ( child , objs ) end end end return objs end function unstringify_data ( str ) local obj = {} local count = 1 local last_key = nil for s in string.gmatch ( str , \"([^|]+)\" ) do if ( s ~= \"\" ) then if ( count == 1 ) then last_key = s obj [ s ] = {} end if ( count > 1 ) then obj [ last_key ][ count - 1 ] = s end count = count + 1 if ( count > 4 ) then count = 1 end end end return obj end","title":"Saving Colors"},{"location":"examples/example5/#saving-colors","text":"This example is an extra bonus but more advanced. What's the point of allowing the players to change colors of an object if they don't save? So some important things to note about this example: Enable saving_enabled on the Advanced_Color_Picker_Save_Load_Client script. It is disabled by default. Your mesh root needs to be networked and have a networked property called data . See the example by looking at Mesh Root . Player Data has a limit of how much can be stored, so if you are letting the player color the world, expect to hit the limit. For simple objects where it may be a hat, or some clothing, then this should be fine. This example storage an object that is built up of the mesh ids and the color picked. We send the data to a server script which handles saving to Player Storage. When a player logs back in, we convert the data into a string and use a networked property so we can get it to the client. See Storage for more information.","title":"Saving Colors"},{"location":"examples/example5/#the-server-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 local mesh_root = script : GetCustomProperty ( \"mesh_root\" ): WaitForObject () local enable_loading = script : GetCustomProperty ( \"enable_loading\" ) -- Turns a table of that was stored in the player storage into a string so we can -- set the networked property value. function stringify_data ( data ) local str = {} for k , v in pairs ( data ) do table.insert ( str , # str + 1 , string.format ( \"|%s|%.2f|%.2f|%.2f\" , k , v . r , v . g , v . b )) end return table.concat ( str ) end -- When player joins the game, grab their data, turn it into a string, and send it to them -- via a networked property. Game . playerJoinedEvent : Connect ( function ( player ) local data = Storage . GetPlayerData ( player ) or {} mesh_root : SetNetworkedCustomProperty ( \"data\" , stringify_data ( data )) end ) -- Handles saving the color to storage for the player. Events . ConnectForPlayer ( \"on_color_picker_save\" , function ( player , id , color ) local data = Storage . GetPlayerData ( player ) or {} data [ id ] = color Storage . SetPlayerData ( player , data ) end )","title":"The Server Script"},{"location":"examples/example5/#the-client-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 local mesh_root = script : GetCustomProperty ( \"mesh_root\" ): WaitForObject () local enable_saving = script : GetCustomProperty ( \"enable_saving\" ) -- If saving is enabled, then we broadcast to the server when a color is changed. -- Ideally it would be nice not to have to broadcast every time, but if we try to send -- all the colors and mesh ids to the server, we will hit either broadcast rate limits, -- or data limits. if ( enable_saving ) then Events . Connect ( \"on_color_picker_object_changed\" , function ( id , color ) local a , j = string.find ( id , \":\" ) Events . BroadcastToServer ( \"on_color_picker_save\" , string.sub ( id , 0 , j - 1 ), color ) end ) end -- Here we listen for a change on the networked property. We handle turning the -- data back into a table so we can then apply the colors to the mesh. mesh_root . networkedPropertyChangedEvent : Connect ( function ( obj , prop ) if ( prop == \"data\" ) then local data = unstringify_data ( mesh_root : GetCustomProperty ( prop )) local objs = get_objects ( mesh_root , {}) for k , v in pairs ( data ) do for o = 1 , # objs do local a , j = string.find ( objs [ o ]. id , \":\" ) local id = string.sub ( objs [ o ]. id , 0 , j - 1 ) if ( id == k ) then objs [ o ]: SetColor ( Color . New ( v [ 1 ], v [ 2 ], v [ 3 ])) end end end end end ) function get_objects ( r , objs ) local children = r : GetChildren () for c = 1 , # children do local child = children [ c ] if ( not child : GetCustomProperty ( \"ignore_color_picker\" )) then if ( child : IsA ( \"StaticMesh\" )) then table.insert ( objs , # objs + 1 , child ) elseif ( child : IsA ( \"Folder\" )) then objs = get_objects ( child , objs ) end end end return objs end function unstringify_data ( str ) local obj = {} local count = 1 local last_key = nil for s in string.gmatch ( str , \"([^|]+)\" ) do if ( s ~= \"\" ) then if ( count == 1 ) then last_key = s obj [ s ] = {} end if ( count > 1 ) then obj [ last_key ][ count - 1 ] = s end count = count + 1 if ( count > 4 ) then count = 1 end end end return obj end","title":"The Client Script"},{"location":"examples/intro/","text":"Trying the Examples To try out the examples you need to do 2 important things first. Enable Player Storage on your Game Settings object (use in a later example). Drag and drop the Advanced Color Picker Examples component into the hierachy. For all examples you need to drag the the Mesh Root folder onto the mesh_root of the Advanced Color Picker component object for each one you want to test.","title":"Trying the Examples"},{"location":"examples/intro/#trying-the-examples","text":"To try out the examples you need to do 2 important things first. Enable Player Storage on your Game Settings object (use in a later example). Drag and drop the Advanced Color Picker Examples component into the hierachy. For all examples you need to drag the the Mesh Root folder onto the mesh_root of the Advanced Color Picker component object for each one you want to test.","title":"Trying the Examples"}]}